# 存储适配器设计

## 目标

- 屏蔽对象存储/NAS 差异，为业务层提供统一接口
- 通过 Spring Boot 自动装配加载单一激活的适配器实现
- 支持同步上传、分片上传、下载、预签名等核心操作
- **分片上传通过 UploadSession 封装**，简化调用方使用

## 模块结构

```
file-srv-adapters/
├── pom.xml                          # 父 POM，依赖 common（获取 SPI 契约）
└── file-srv-adapter-hcs/            # 华为云 OBS 适配器
    ├── pom.xml
    └── src/main/java/tech/icc/filesrv/adapter/
        ├── hcs/
        │   ├── HcsStorageAdapter.java     # 适配器实现
        │   ├── HcsUploadSession.java      # 分片上传会话实现
        │   └── config/
        │       ├── HcsObsAutoConfiguration.java
        │       └── ObsProperties.java
        └── model/
            └── FileMetadata.java    # 文件元数据 DTO
```

## 接口定义

### StorageAdapter 接口 (修订版)

位置：`file-srv-common/src/main/java/tech/icc/filesrv/common/spi/storage/StorageAdapter.java`

```java
public interface StorageAdapter {

    // ==================== 简单文件操作 ====================

    /**
     * 上传文件（适用于小文件）
     * @param path 存储路径
     * @param data 文件数据流
     * @param size 文件大小
     * @param contentType MIME 类型
     */
    void put(String path, InputStream data, long size, String contentType);

    /**
     * 下载文件，返回输入流（调用方负责关闭）
     * @param path 存储路径
     * @return 文件输入流
     */
    InputStream get(String path);

    /**
     * 删除文件（幂等，不存在时不抛异常）
     * @param path 存储路径
     */
    void delete(String path);

    /**
     * 检查文件是否存在
     * @param path 存储路径
     * @return 是否存在
     */
    boolean exists(String path);

    // ==================== 预签名 ====================

    /**
     * 生成预签名下载 URL
     * @param path 存储路径
     * @param expiry 有效期
     * @return 预签名 URL
     */
    URI presignDownload(String path, Duration expiry);

    // ==================== 分片上传 ====================

    /**
     * 开始分片上传会话
     * @param path 存储路径
     * @param contentType MIME 类型
     * @return 上传会话
     */
    UploadSession beginUpload(String path, String contentType);
}
```

### UploadSession 接口 (新增)

位置：`file-srv-core/src/main/java/tech/icc/filesrv/core/infra/storage/UploadSession.java`

```java
/**
 * 分片上传会话，封装 S3/OBS 等存储的分片上传细节
 *
 * <p>设计目的：
 * <ul>
 *   <li>屏蔽不同存储的分片 API 差异</li>
 *   <li>简化调用方使用：不需要关心 uploadId、objectKey 等内部概念</li>
 *   <li>支持会话持久化与恢复</li>
 * </ul>
 */
public interface UploadSession extends AutoCloseable {

    /**
     * 获取会话 ID（用于持久化和恢复）
     * 对于 S3/OBS 实现，这通常是 uploadId
     */
    String getSessionId();

    /**
     * 上传单个分片
     * @param partNumber 分片序号（1-based）
     * @param data 分片数据流
     * @param size 分片大小
     * @return 该分片的 ETag
     */
    String uploadPart(int partNumber, InputStream data, long size);

    /**
     * 完成上传，合并所有分片
     * @param parts 所有分片信息（partNumber + etag）
     * @return 最终文件的存储路径
     */
    String complete(List<PartInfo> parts);

    /**
     * 中止上传，清理已上传的分片
     */
    void abort();

    /**
     * 资源释放
     */
    @Override
    void close();
}
```

### PartInfo 值对象

位置：`file-srv-core/src/main/java/tech/icc/filesrv/core/domain/tasks/PartInfo.java`

```java
/**
 * 分片信息值对象
 */
public record PartInfo(
    int partNumber,     // 分片序号 (1-based)
    String etag,        // 存储层返回的 ETag
    long size           // 分片大小
) {}
```

## 接口演进说明

| 原接口                            | 新接口                               | 说明                        |
| --------------------------------- | ------------------------------------ | --------------------------- |
| `uploadFile(in, meta)`            | `put(path, data, size, contentType)` | 简化参数，path 由调用方决定 |
| `downloadFile(fkey)`              | `get(path)`                          | 统一命名                    |
| `generatePresignedUrl(fkey, exp)` | `presignDownload(path, expiry)`      | 明确是下载签名              |
| `deleteFile(fkey)`                | `delete(path)`                       | 统一命名                    |
| `exists(fkey)`                    | `exists(path)`                       | 保持不变                    |
| `initiateMultipartUpload`         | `beginUpload() → session`            | 封装到 Session              |
| `uploadPart`                      | `session.uploadPart()`               | 封装到 Session              |
| `completeMultipartUpload`         | `session.complete()`                 | 封装到 Session              |
| `abortMultipartUpload`            | `session.abort()`                    | 封装到 Session              |

## 辅助 DTO

#### FileMetadata（保留用于内部）

```java
@Data
public class FileMetadata {
    private String filename;
    private Long size;
    private String contentType;
    private String creator;
    private List<String> tags;
    private String bucket;
    private String objectKey;  // 对象键，= path
}
```

## 华为云 OBS 适配器实现

### HcsStorageAdapter

已实现功能：

| 方法              | 状态 | 说明                            |
| ----------------- | ---- | ------------------------------- |
| `put`             | ✅   | 使用 `PutObjectRequest` 上传    |
| `get`             | ✅   | 使用 `getObject` 获取流         |
| `presignDownload` | ✅   | 使用 `createTemporarySignature` |
| `delete`          | ✅   | 使用 `deleteObject`             |
| `exists`          | ✅   | 使用 `doesObjectExist`          |
| `beginUpload`     | ✅   | 返回 `HcsUploadSession`         |

### HcsUploadSession

```java
public class HcsUploadSession implements UploadSession {

    private final ObsClient obsClient;
    private final String bucket;
    private final String objectKey;
    private final String uploadId;

    // 构造时调用 initiateMultipartUpload
    public HcsUploadSession(ObsClient client, String bucket, String key, String contentType) {
        this.obsClient = client;
        this.bucket = bucket;
        this.objectKey = key;
        this.uploadId = initUpload(contentType);
    }

    @Override
    public String getSessionId() {
        return uploadId;
    }

    @Override
    public String uploadPart(int partNumber, InputStream data, long size) {
        UploadPartResult result = obsClient.uploadPart(
            new UploadPartRequest(bucket, objectKey, uploadId, partNumber, data, size)
        );
        return normalizeETag(result.getEtag());
    }

    @Override
    public String complete(List<PartInfo> parts) {
        List<PartEtag> obsParts = parts.stream()
            .sorted(Comparator.comparingInt(PartInfo::partNumber))
            .map(p -> new PartEtag(p.etag(), p.partNumber()))
            .toList();
        obsClient.completeMultipartUpload(
            new CompleteMultipartUploadRequest(bucket, objectKey, uploadId, obsParts)
        );
        return objectKey;
    }

    @Override
    public void abort() {
        obsClient.abortMultipartUpload(
            new AbortMultipartUploadRequest(bucket, objectKey, uploadId)
        );
    }

    @Override
    public void close() {
        // 资源清理（如有需要）
    }
}
```

### 自动装配配置

```java
@AutoConfiguration
@EnableConfigurationProperties(ObsProperties.class)
@ConditionalOnClass(ObsClient.class)
public class HcsObsAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "storage.obs.enabled", havingValue = "true")
    public ObsClient obsClient(ObsProperties properties) {
        // 校验配置并创建 ObsClient
    }

    @Bean
    @ConditionalOnMissingBean(StorageAdapter.class)
    @ConditionalOnProperty(name = "storage.obs.enabled", havingValue = "true")
    public StorageAdapter hcsObsAdapter(ObsClient obsClient, ObsProperties properties) {
        return new HcsObsAdapter(obsClient, properties);
    }
}
```

### 配置属性

```yaml
storage:
  obs:
    enabled: true
    endpoint: https://obs.cn-north-4.myhuaweicloud.com
    bucket-name: ${OBS_BUCKET}
    access-key: ${OBS_ACCESS_KEY}
    secret-key: ${OBS_SECRET_KEY}
    presigned-url-expiration: 3600s # 预签名 URL 默认有效期
```

## 异常处理

- 捕获 SDK 异常，转换为 `FileServiceException`
- 错误码定义在 `ResultCode`

| 场景               | 处理方式             |
| ------------------ | -------------------- |
| 鉴权失败           | 抛出异常             |
| 桶/对象不存在      | `NOT_FOUND` 错误码   |
| 网络超时           | 抛出异常，上层重试   |
| 分片合并失败       | 抛出异常             |
| abort 时对象不存在 | 幂等返回（不抛异常） |

## ETag 标准化

OBS SDK 返回的 ETag 带引号，需要标准化：

```java
private String normalizeETag(String etag) {
    if (etag != null && etag.startsWith("\"") && etag.endsWith("\"")) {
        return etag.substring(1, etag.length() - 1);
    }
    return etag;
}
```

## 防腐层设计原则

### 设计哲学

**Adapter 作为防腐层（Anti-Corruption Layer），其核心职责是：**

1. **向上屏蔽差异**：为 Core 层提供统一的、符合领域语义的接口
2. **向下适配技术**：吸收不同存储技术的实现细节和复杂度
3. **单向依赖**：Core 层定义接口契约，Adapter 层实现契约
4. **技术无关**：Core 层代码不应包含任何存储技术的特定概念

### 抽象设计原则

#### 原则 1：以主流存储为抽象基准

**决策：以对象存储（S3/OBS）的分片上传模型作为主抽象**

理由：

- 产品定位是 "S3-like RESTful API"
- 对象存储是云原生基础设施的标准
- 分片上传是大文件场景的核心需求

**不采用"最小公约数"抽象**：

```java
// ❌ 错误的设计：降低到最小公约数
interface StorageAdapter {
    void put(String path, InputStream data);  // 放弃分片上传能力
    InputStream get(String path);
    // 结果：为了兼容最弱的存储，牺牲了 90% 的高级特性
}

// ✅ 正确的设计：以主流能力为基准
interface StorageAdapter {
    UploadSession beginUpload(String path, String contentType);  // 保留分片上传
    InputStream get(String path);
    // 结果：非对象存储通过 Adapter 适配到此抽象
}
```

#### 原则 2：Adapter 吸收差异，而非暴露差异

**Core 层不应感知存储实现细节：**

```java
// ❌ 错误：将存储细节暴露给 Core 层
interface StorageAdapter {
    UploadSession beginUpload(String path, String contentType,
                              long totalSize,    // 文件系统需要
                              long partSize,     // 文件系统需要
                              boolean preallocate); // 文件系统需要
}

// ✅ 正确：Adapter 内部处理所有细节
interface StorageAdapter {
    UploadSession beginUpload(String path, String contentType);
    // 各 Adapter 自行决定如何实现
}
```

### 具体案例：OBS vs NAS

#### 案例 1：分片上传的适配策略

**对象存储（OBS）：原生支持分片上传**

```java
class HcsObsAdapter implements StorageAdapter {

    @Override
    public UploadSession beginUpload(String path, String contentType) {
        // 直接使用 OBS 原生的分片上传 API
        InitiateMultipartUploadRequest request =
            new InitiateMultipartUploadRequest(bucket, path);
        request.setMetadata(metadata);

        String uploadId = obsClient.initiateMultipartUpload(request)
                                   .getUploadId();

        return new HcsUploadSession(obsClient, bucket, path, uploadId);
    }
}

class HcsUploadSession implements UploadSession {

    @Override
    public String uploadPart(int partNumber, InputStream data, long size) {
        // 直接调用 OBS SDK
        UploadPartResult result = obsClient.uploadPart(
            new UploadPartRequest(bucket, objectKey, uploadId,
                                 partNumber, data, size)
        );
        return normalizeETag(result.getEtag());
    }

    @Override
    public String complete(List<PartETagInfo> parts) {
        // 直接调用 OBS 完成接口
        obsClient.completeMultipartUpload(
            new CompleteMultipartUploadRequest(bucket, objectKey,
                                              uploadId, obsParts)
        );
        return objectKey;
    }
}
```

**特点**：

- ✅ **零开销**：直接映射到 OBS API
- ✅ **有状态会话**：uploadId 可持久化、可跨进程恢复
- ✅ **并发友好**：分片可并发、乱序上传
- ✅ **两阶段提交**：完成时才真正生成对象

---

**网络文件存储（NAS）：模拟分片上传**

```java
class NasAdapter implements StorageAdapter {

    @Override
    public UploadSession beginUpload(String path, String contentType) {
        // NAS 不需要初始化，延迟到第一次 uploadPart
        return new NasUploadSession(path);
    }
}

class NasUploadSession implements UploadSession {
    private final Path filePath;
    private RandomAccessFile raf;
    private final Map<Integer, Long> partOffsets = new ConcurrentHashMap<>();

    @Override
    public String uploadPart(int partNumber, InputStream data, long size) {
        // 第一次调用时才创建文件
        if (raf == null) {
            Files.createDirectories(filePath.getParent());
            raf = new RandomAccessFile(filePath.toFile(), "rw");
        }

        // 基于偏移量的随机写入（无需顺序）
        long offset = calculateOffset(partNumber);
        long requiredSize = offset + size;

        // 按需扩展文件大小（无需预知总大小）
        if (raf.length() < requiredSize) {
            raf.setLength(requiredSize);
        }

        synchronized (raf) {
            raf.seek(offset);
            data.transferTo(Channels.newOutputStream(raf.getChannel()));
        }

        partOffsets.put(partNumber, offset);
        return String.valueOf(partNumber);  // 伪 ETag
    }

    @Override
    public String complete(List<PartETagInfo> parts) {
        // 所有分片已写入最终位置，无需合并
        raf.getFD().sync();  // 强制刷盘
        raf.close();

        log.info("NAS upload completed: path={}, parts={}",
                 filePath, parts.size());
        return filePath.toString();
    }

    private long calculateOffset(int partNumber) {
        // 策略 1：固定分片大小（如 5MB）
        long defaultPartSize = 5 * 1024 * 1024;
        return (partNumber - 1L) * defaultPartSize;

        // 策略 2：动态记录每个分片的位置（支持变长分片）
        // 如果后续需要更精确的控制，可以维护 partOffsets Map
    }
}
```

**特点**：

- ✅ **延迟初始化**：beginUpload() 无实际 I/O，第一次 uploadPart() 才创建文件
- ✅ **随机写入**：基于偏移量直接写入目标位置（类似 BT 下载）
- ✅ **零拷贝**：无需临时文件，直接写最终位置
- ✅ **动态扩展**：无需预知文件总大小，按需扩展
- ✅ **接口兼容**：完全符合 StorageAdapter 契约

#### 案例 2：会话恢复（resumeUpload）

**对象存储（OBS）：**

```java
@Override
public UploadSession resumeUpload(String path, String sessionId) {
    // sessionId = uploadId（服务端资源）
    // 直接恢复，无需额外查询
    return new HcsUploadSession(obsClient, bucket, path, sessionId, true);
}
```

**网络文件存储（NAS）：**

```java
@Override
public UploadSession resumeUpload(String path, String sessionId) {
    // sessionId = 临时文件标识
    Path file = Paths.get(path);

    if (!Files.exists(file)) {
        throw new SessionExpiredException("File not found: " + path);
    }

    // 恢复已存在的文件
    RandomAccessFile raf = new RandomAccessFile(file.toFile(), "rw");
    return new NasUploadSession(path, raf);
}
```

#### 案例 3：ETag 语义差异

**对象存储（OBS）：**

```java
// ETag 是内容的 MD5/SHA256 哈希，用于完整性校验
String etag = result.getEtag();  // "a3f5b8c2d1e9..."
```

**网络文件存储（NAS）：**

```java
// 文件系统无 ETag 概念，返回伪值（分片序号）
return String.valueOf(partNumber);  // "1", "2", "3"
// Core 层不关心 ETag 的真实语义，只用于完成时提供分片列表
```

### 适配的价值

#### 1. **业务代码稳定**

```java
// TaskService 完全不需要关心底层存储
@Transactional
public PartETagDto uploadPart(String taskId, int partNumber,
                              InputStream content, long size) {
    TaskAggregate task = getTaskOrThrow(taskId);

    // 这段代码对 OBS 和 NAS 完全一致
    String storagePath = buildStoragePath(task.getFKey(), task.getContentType());
    UploadSession session = storageAdapter.resumeUpload(
        storagePath, task.getSessionId()
    );

    String etag = session.uploadPart(partNumber, content, size);
    // ...
}
```

#### 2. **灵活切换存储**

```yaml
# 配置切换，无需修改代码
storage:
  type: obs # 或 nas, oss, s3, minio...
  obs:
    enabled: true
    endpoint: https://obs.example.com
    bucket: my-bucket
```

#### 3. **降低测试复杂度**

```java
// 单元测试：Mock Adapter
@Test
void testCreateTask() {
    StorageAdapter adapter = mock(StorageAdapter.class);
    when(adapter.beginUpload(any(), any()))
        .thenReturn(mockSession);

    TaskService service = new TaskService(adapter, ...);
    // 无需真实存储环境
}

// 集成测试：使用 NAS Adapter（本地文件系统）
@SpringBootTest
@TestPropertySource(properties = "storage.type=nas")
class TaskServiceIntegrationTest {
    // 无需 OBS 环境，直接用本地文件测试完整流程
}
```

#### 4. **支持未来扩展**

```
当前实现：
- ✅ HcsObsAdapter (华为云 OBS)

未来可无缝添加：
- ⏳ AliyunOssAdapter (阿里云 OSS)
- ⏳ AwsS3Adapter (AWS S3)
- ⏳ MinioAdapter (MinIO)
- ⏳ NasAdapter (NAS/NFS)
- ⏳ CephAdapter (Ceph RGW)

添加新 Adapter 的成本：
- Core 层：0 行代码修改
- 新 Adapter：~300 行代码
- 配置：新增一个 @AutoConfiguration 类
```

### 设计权衡

| 方案                                | 优点                              | 缺点                                |
| ----------------------------------- | --------------------------------- | ----------------------------------- |
| **最小公约数抽象**                  | 所有存储都能"直接"实现            | 高级特性无法使用，产品能力退化      |
| **暴露存储细节给 Core**             | Adapter 实现简单                  | Core 层与存储技术耦合，违背防腐原则 |
| **Adapter 适配差异**（✅ 当前方案） | Core 层稳定，充分利用主流存储能力 | 部分 Adapter 需要额外工作（可接受） |

### 结论

**防腐层的本质是单向依赖倒置：**

```
领域层（Core）  →  定义契约（接口）
      ↑
      │ 依赖方向：向上实现
      │
适配层（Adapter）  →  实现契约（适配存储技术）
      ↑
      │
外部系统（OBS/NAS/OSS/S3...）
```

- **Core 层**：定义"我需要什么能力"（分片上传、下载、预签名）
- **Adapter 层**：实现"如何提供这些能力"（OBS 原生支持 / NAS 模拟实现）
- **价值**：业务逻辑与技术实现解耦，支持灵活切换和未来扩展

## 其他存储（未来扩展）

| 存储类型     | 适配策略                            | 分片上传实现            |
| ------------ | ----------------------------------- | ----------------------- |
| OSS/COS/S3   | 接口一致，主要差异在 SDK 与签名方式 | 原生支持，直接映射      |
| MinIO/Ceph   | S3 兼容协议，可复用 S3 适配器       | 原生支持                |
| NAS/NFS      | 自定义实现                          | 随机写入 + 动态扩展文件 |
| 本地文件系统 | 同 NAS                              | 随机写入 + 稀疏文件     |

## 监控指标（建议）

- 上传/下载耗时、吞吐、失败率
- 分片重试次数、合并失败次数
- 预签名 URL 请求量

## 测试建议

- **单元测试**：Mock ObsClient 验证适配器逻辑
- **集成测试**：使用 Testcontainer + MinIO 模拟 S3 兼容存储
- **压力测试**：验证 10k 分片、大文件、并发上传
