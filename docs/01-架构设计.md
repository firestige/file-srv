# 架构设计

## 总览

ICC File Service 采用 **领域驱动设计（DDD）** 分层架构，结合适配器模式，通过 Spring Boot 自动装配加载存储后端，持久化元数据与任务状态，利用 Redis 做缓存，满足无状态横向扩容。

## DDD 分层架构

### 整体结构

```
┌─────────────────────────────────────────────────────────────────┐
│                       file-srv-core                             │
├─────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              应用层 (application/)                         │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │  entrypoint/                                        │  │  │
│  │  │    ├── FileController      (文件操作 REST API)       │  │  │
│  │  │    ├── TaskController      (上传任务 REST API)       │  │  │
│  │  │    ├── StaticResourceController (静态资源访问)        │  │  │
│  │  │    ├── model/              (API层 请求/响应 DTO)     │  │  │
│  │  │    │    ├── FileInfoResponse   (文件信息响应)        │  │  │
│  │  │    │    ├── TaskResponse       (任务响应，sealed)    │  │  │
│  │  │    │    ├── MetaQueryRequest   (元数据查询请求)      │  │  │
│  │  │    │    └── PartETag           (分片ETag)           │  │  │
│  │  │    └── assembler/          (DTO转换器)              │  │  │
│  │  │         ├── FileInfoAssembler  (FileInfoDto ↔ Response)│  │
│  │  │         └── TaskInfoAssembler  (TaskInfoDto ↔ Response)│  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │  service/                                           │  │  │
│  │  │    ├── FileService         (文件应用服务)            │  │  │
│  │  │    ├── TaskService         (任务应用服务)            │  │  │
│  │  │    └── dto/                (应用层 DTO)             │  │  │
│  │  │         ├── FileInfoDto        (文件信息)           │  │  │
│  │  │         ├── TaskInfoDto        (任务信息，sealed)    │  │  │
│  │  │         ├── MetaQueryCriteria  (查询条件)           │  │  │
│  │  │         └── PartETagDto        (分片ETag)           │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              领域层 (domain/)                              │  │
│  │    ├── files/                 (文件聚合)                   │  │
│  │    │    ├── FileReference     (用户文件引用，聚合根)        │  │
│  │    │    ├── FileInfo          (物理文件实体，去重核心)       │  │
│  │    │    ├── FileStatus        (文件状态枚举)               │  │
│  │    │    └── Repository        (仓储接口)                   │  │
│  │    ├── storage/               (存储聚合)                   │  │
│  │    │    ├── StorageNode       (存储节点)                   │  │
│  │    │    ├── StorageCopy       (存储副本)                   │  │
│  │    │    ├── StoragePolicy     (存储策略)                   │  │
│  │    │    └── Enums             (Tier/Status 枚举)          │  │
│  │    ├── services/              (领域服务)                   │  │
│  │    │    ├── DeduplicationService  (去重服务)               │  │
│  │    │    └── StorageRoutingService (路由服务)               │  │
│  │    └── tasks/                 (任务聚合，已有)              │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              基础设施层 (infra/)                           │  │
│  │    ├── storage/                                           │  │
│  │    │    ├── StorageAdapter        (存储适配器接口)         │  │
│  │    │    ├── StorageResult         (上传结果)              │  │
│  │    │    └── StorageAdapterRegistry(适配器注册中心)         │  │
│  │    └── plugin/                                            │  │
│  │         └── SharedPlugin          (插件接口)               │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 分层职责

| 层级           | 包路径         | 职责                                               |
| -------------- | -------------- | -------------------------------------------------- |
| **应用层**     | `application/` | 编排领域对象完成用例，暴露 REST API，DTO 转换      |
| **领域层**     | `domain/`      | 核心业务逻辑，聚合根、实体、值对象、领域服务       |
| **基础设施层** | `infra/`       | 技术实现接口定义（存储、插件），具体实现在外部模块 |

### DTO 分层设计

应用层内部进一步划分为 **API 层**（entrypoint）和 **服务层**（service），各层拥有独立的 DTO 定义，通过 Assembler 进行显式转换。

#### 设计原则

| 概念                    | 定义                     | 跨层策略     | 示例                                |
| ----------------------- | ------------------------ | ------------ | ----------------------------------- |
| **VO（值对象）**        | 与事实绑定的不可变数据   | 跨层共享     | `TaskStatus`、`FileRequest`         |
| **DTO（数据传输对象）** | 与业务场景绑定的数据集合 | 每层各自定义 | `FileInfoDto` vs `FileInfoResponse` |

#### 层间 DTO 划分

```
┌─────────────────────────────────────────────────────────────────┐
│  API 层 (entrypoint/model)                                      │
│  ────────────────────────                                       │
│  职责：HTTP 传输，面向客户端                                      │
│  特征：@JsonTypeInfo, @JsonSubTypes, @Valid 等序列化/验证注解     │
│                                                                  │
│  FileInfoResponse    ──┐                                        │
│  TaskResponse        ──┼── 包含 JSON 多态序列化注解               │
│  MetaQueryRequest    ──┤   包含 Bean Validation 注解             │
│  PartETag            ──┘                                        │
└────────────────────────────────┬────────────────────────────────┘
                                 │ Assembler 转换
┌────────────────────────────────▼────────────────────────────────┐
│  服务层 (service/dto)                                            │
│  ────────────────────                                            │
│  职责：业务逻辑处理，面向领域层                                    │
│  特征：纯数据结构，无框架依赖注解                                  │
│                                                                  │
│  FileInfoDto         ──┐                                        │
│  TaskInfoDto         ──┼── 纯 Java 数据类（record / sealed）     │
│  MetaQueryCriteria   ──┤   无序列化/验证注解                      │
│  PartETagDto         ──┘                                        │
└─────────────────────────────────────────────────────────────────┘
```

#### Assembler 模式

Assembler 负责 API 层与服务层 DTO 的双向转换，集中管理转换逻辑：

```java
// FileInfoAssembler - 文件信息转换
public final class FileInfoAssembler {
    public static FileInfoResponse toResponse(FileInfoDto dto) { ... }
    public static MetaQueryCriteria toCriteria(MetaQueryRequest request) { ... }
}

// TaskInfoAssembler - 任务信息转换
public final class TaskInfoAssembler {
    public static TaskResponse toResponse(TaskInfoDto dto) { ... }
    public static PartETagDto toDto(PartETag partETag) { ... }
}
```

#### 设计收益

| 收益         | 说明                                            |
| ------------ | ----------------------------------------------- |
| **解耦**     | 服务层不依赖 HTTP/JSON 框架注解，可独立测试     |
| **灵活**     | API 层响应格式变化不影响业务逻辑                |
| **类型安全** | sealed interface 配合 record 实现编译期类型检查 |
| **职责清晰** | 验证在 API 层完成，服务层专注业务逻辑           |

## 模块依赖关系

```
                    ┌─────────────────────┐
                    │   file-srv-test     │  (集成测试)
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │ file-srv-autoconfig │  (Spring 自动装配)
                    └──────────┬──────────┘
                               │
        ┌──────────────────────┼──────────────────────┐
        │                      │                      │
┌───────▼───────┐   ┌─────────▼─────────┐   ┌───────▼───────┐
│file-srv-aspect│   │  file-srv-adapters │   │file-srv-plugins│
│  (切面模块)    │   │   (存储适配器)      │   │   (插件模块)   │
└───────┬───────┘   └─────────┬─────────┘   └───────┬───────┘
        │                     │                     │
        │               ┌─────┴─────┐               │
        │               │           │               │
        └───────────────┤   core    │───────────────┘
                        │           │
                        └─────┬─────┘
                              │
                    ┌─────────▼─────────┐
                    │      common       │  (公共模块 + SPI 契约)
                    │  ┌─────────────┐  │
                    │  │    spi/     │  │
                    │  │ ├─storage/  │  │
                    │  │ └─plugin/   │  │
                    │  └─────────────┘  │
                    └───────────────────┘
```

说明：adapters 和 plugins 模块只依赖 common（获取 SPI 契约），不依赖 core。

## 关键设计点

- **DDD 分层**：领域逻辑集中在 `domain/`，应用编排在 `application/`，技术细节在 `infra/` 及外部模块
- **DTO 分层**：API 层与服务层各自定义 DTO，通过 Assembler 显式转换，解耦 HTTP 框架依赖
- **VO 共享**：与事实绑定的值对象（如 `TaskStatus`、`FileRequest`）跨层共享，避免重复定义
- **无状态服务**：会话/任务状态不落本地，依赖 DB + Redis，可水平扩容
- **多级缓存**：Caffeine 进程内热点 + Redis 分布式缓存，降低 DB/存储访问
- **配置驱动适配器加载**：`storage.obs.enabled=true` 触发华为云适配器自动装配
- **统一异常**：SDK/IO 异常转换为 `FileServiceException`，错误码集中在 `ResultCode`
- **插件机制**：上传完成后按顺序调用 `SharedPlugin` 实现后处理扩展
- **可观察性**：Spring Actuator 做健康检查、指标暴露

## 数据流

### 1. 同步上传

```
FileController.uploadFile()
    ↓
FileService.upload()
    ↓
StorageAdapter.uploadFile()  ──→  对象存储 (OBS/OSS/S3...)
    ↓
MetaService.save()  ──→  DB (FileEntity)
    ↓
返回 FileInfo
```

### 2. 分片上传

```
TaskController.createUploadTask()
    ↓
TaskService.create()  ──→  DB (TaskEntity) + Redis (状态缓存)
    ↓
StorageAdapter.initiateMultipartUpload()
    ↓
返回 TaskInfo (含 uploadId)

TaskController.uploadPart()
    ↓
TaskService.recordPart()
    ↓
StorageAdapter.uploadPart()
    ↓
返回 PartUploadInfo (含 eTag)

TaskController.completeUpload()
    ↓
StorageAdapter.completeMultipartUpload()
    ↓
SharedPlugin.apply() × N  (按顺序执行插件)
    ↓
MetaService.save()  ──→  DB (FileEntity)
    ↓
TaskService.complete()  ──→  更新状态
```

### 3. 下载

```
FileController.getFile() / StaticResourceController.staticResource()
    ↓
MetaService.findByFkey()  ←──  Caffeine → Redis → DB
    ↓
StorageAdapter.downloadFile()  或  generatePresignedUrl()
    ↓
返回 Resource / 重定向 URL
```

### 4. 删除

```
FileController.deleteFile()
    ↓
StorageAdapter.deleteFile()  ──→  删除对象存储文件
    ↓
MetaService.delete()  ──→  删除 DB 记录
    ↓
缓存失效  ──→  删除 Redis/Caffeine 缓存
```

## 组件交互示意

```
┌─────────────────────────────────────────────────────────────────┐
│                         应用层                                   │
│  FileController ─┬─→ FileService ─┬─→ StorageAdapter (接口)      │
│  TaskController ─┤                │                             │
│  StaticResource ─┘                └─→ MetaService (待实现)       │
│                                       TaskService (待实现)       │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                         领域层                                   │
│  FileAggregate ←──────────────────────→ TaskAggregate           │
│       │                                       │                  │
│  FileInfo (实体)                        TaskInfo (实体)          │
│                                         TaskStatus (枚举)        │
└───────────────────────────┬─────────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────────┐
│                       基础设施层                                 │
│                                                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ StorageAdapter  │  │  SharedPlugin   │  │   Repository    │  │
│  │    (接口)       │  │    (接口)       │  │    (JPA)        │  │
│  └────────┬────────┘  └────────┬────────┘  └─────────────────┘  │
└───────────┼────────────────────┼────────────────────────────────┘
            │ (实现在外部模块)     │ (实现在外部模块)
┌───────────▼───────────┐  ┌─────▼─────────────────┐
│   file-srv-adapters   │  │    file-srv-plugins   │
│  ┌─────────────────┐  │  │  ┌─────────────────┐  │
│  │ HcsObsAdapter   │  │  │  │ RenamePlugin    │  │
│  │ (华为云OBS)     │  │  │  │ (示例)          │  │
│  └─────────────────┘  │  │  └─────────────────┘  │
└───────────────────────┘  └───────────────────────┘
```

## 配置示例

```yaml
# 存储配置
storage:
  obs:
    enabled: true
    endpoint: https://obs.cn-north-4.myhuaweicloud.com
    bucket-name: ${OBS_BUCKET}
    access-key: ${OBS_ACCESS_KEY}
    secret-key: ${OBS_SECRET_KEY}
    presigned-url-expiration: 3600s

# Redis 配置
spring:
  redis:
    host: localhost
    port: 6379
  datasource:
    url: jdbc:mysql://localhost:3306/filesrv
    username: root
    password: ${DB_PASSWORD}
```

## 非功能性目标

- **可扩展性**：适配器接口稳定，新增存储零侵入业务层；插件机制支持后处理扩展
- **可靠性**：分片上传支持重试、幂等；任务状态可恢复
- **性能**：多级缓存、直连预签名下载、分片并发上传
- **安全**：凭证隔离（配置/环境变量），预签名有效期控制，最小权限的存储账号
- **可观测性**：Spring Actuator 健康检查、指标暴露

## TaskContext 设计（P0/P2/P3）

### 概述

TaskContext 是一个**线程安全的任务上下文**，在 Callback 插件执行期间传递任务元数据、文件信息和运行时状态。

### 核心职责

| 职责         | 说明                                                     |
| ------------ | -------------------------------------------------------- |
| **元数据注入** | 自动注入任务、文件、用户、存储等核心元数据（P0）          |
| **插件通信** | 插件间通过 context 共享数据（P2 TaskContextKeys）         |
| **资源管理** | 提供临时文件路径和清理通知（P0）                          |
| **诊断调试** | 提供运行时诊断信息（P3）                                  |

### 关键设计原则

| 原则             | 说明                                               |
| ---------------- | -------------------------------------------------- |
| **不变性**       | 通过 `Collections.unmodifiable*` 保护内部集合      |
| **线程安全**     | 使用 `ConcurrentHashMap` 实现并发访问              |
| **类型安全**     | 强类型方法 + 泛型 `get()`                          |
| **清晰职责**     | TaskContext 只负责数据容器，不依赖业务服务         |
| **Aware 模式**   | 通过 Spring ApplicationAware 注入可选服务（P2）    |

### 元数据注入机制（P0）

```java
// DefaultCallbackChainRunner 中注入
TaskContext context = TaskContext.create();

// 核心元数据（P0.2 自动注入）
context.put(TaskContextKeys.TASK_ID, aggregate.taskId().value());
context.put(TaskContextKeys.TASK_STATUS, aggregate.status());
context.put(TaskContextKeys.FILE_NAME, aggregate.filename());
context.put(TaskContextKeys.FILE_SIZE, aggregate.size());
context.put(TaskContextKeys.FILE_HASH, aggregate.contentHash());
context.put(TaskContextKeys.FILE_CONTENT_TYPE, aggregate.contentType());

// 文件路径（P0.5 资源管理）
context.put(TaskContextKeys.LOCAL_FILE_PATH, localFilePath.toString());

// 用户和存储信息
context.put(TaskContextKeys.USER_ID, aggregate.userId().value());
context.put(TaskContextKeys.STORAGE_NODE_ID, "primary");
```

### TaskContextKeys 常量类（P2.9）

统一管理所有 context key 定义，240+ 行，包含：

- **任务元数据**：`TASK_ID`, `TASK_STATUS`, `TASK_CALLBACK_CHAIN` 等
- **文件元数据**：`FILE_NAME`, `FILE_SIZE`, `FILE_HASH`, `FILE_CONTENT_TYPE` 等
- **用户信息**：`USER_ID`, `USER_TENANT_ID`, `USER_DEPT_ID` 等
- **存储信息**：`STORAGE_NODE_ID`, `LOCAL_FILE_PATH`, `STORAGE_PATH` 等
- **交付密钥生成器**：`generateDeliveryKey(prefix, taskId)`

### Aware 模式注入（P2.10）

插件可通过实现 `PluginStorageServiceAware` 接口获得 `PluginStorageService` 实例：

```java
// DefaultCallbackChainRunner 中的注入逻辑
for (SharedPlugin plugin : plugins) {
    if (plugin instanceof PluginStorageServiceAware aware) {
        aware.setPluginStorageService(pluginStorageService);
    }
    result = plugin.apply(context);
}
```

**PluginStorageService 提供的能力**：
- `uploadLargeFile()`: 上传大文件（自动选择单次/分片）
- `downloadFile()`: 下载文件到本地
- `deleteFile()`: 删除存储文件
- `getTemporaryUrl()`: 生成临时访问 URL

### FileRelations 自动维护（P0.1/P0.3）

TaskContext 支持派生文件关系跟踪，通过 **领域事件** 实现解耦：

```java
// TaskContext 中记录派生文件
List<String> derivedKeys = context.getStringList(TaskContextKeys.DERIVED_FILE_KEYS);

// Callback 执行完成后发布事件（P0.3）
if (!derivedKeys.isEmpty()) {
    applicationEventPublisher.publishEvent(
        new DerivedFilesAddedEvent(
            this,
            taskId,
            sourceFileKey,
            derivedKeys
        )
    );
}

// FileRelationsEventHandler 监听事件并更新数据库（P0.3）
@EventListener
public void handleDerivedFilesAdded(DerivedFilesAddedEvent event) {
    // 查询或创建 FileRelations
    // 添加派生文件键
    // 保存到数据库
}
```

### 诊断方法（P3.13）

```java
// 获取所有可用的 key
Set<String> allKeys = context.getAvailableKeys();

// 获取诊断信息
Map<String, Object> diagnostics = context.getDiagnosticInfo();
// 包含：totalKeys, taskId, taskStatus, fileName, fileSize, 
//      metadataChanges, derivedFiles, builtinKeys, pluginKeys
```

### TaskContext 架构决策记录

| 决策点             | 选择                   | 理由                                     |
| ------------------ | ---------------------- | ---------------------------------------- |
| 状态管理           | ConcurrentHashMap      | 线程安全、高并发性能                     |
| 服务依赖注入       | Aware 模式（P2）       | 避免 TaskContext 依赖业务服务            |
| 派生文件维护       | 领域事件（P0）         | 解耦 TaskAggregate 与 FileRelations      |
| 常量管理           | TaskContextKeys 类     | 统一定义、类型安全、IDE 自动补全         |
| 诊断能力           | 专用方法（P3）         | 支持调试、监控、问题排查                 |

## AOP 切面设计（P1.8）

### TaskContextLoggingAspect

为所有 TaskContext 操作添加日志和 MDC 上下文传播。

```java
@Aspect
@Component
public class TaskContextLoggingAspect {
    
    @Around("execution(* tech.icc.filesrv.common.domain.TaskContext.*(..))")
    public Object logTaskContextOperation(ProceedingJoinPoint joinPoint) {
        // 1. 从 TaskContext 提取 taskId
        // 2. 将 taskId 放入 MDC
        // 3. 执行方法
        // 4. 记录操作日志（key 访问、修改）
        // 5. 清理 MDC
    }
}
```

**收益**：
- 所有日志自动包含 `taskId`
- 支持分布式追踪
- 无需修改业务代码

## 生产就绪性增强（P1）

### 1. 孤儿文件清理（P1.6）

```java
@Component
@ConditionalOnProperty(name = "file-srv.orphan-cleanup.enabled", havingValue = "true")
public class OrphanFileCleanupTask {
    
    @Scheduled(cron = "${file-srv.orphan-cleanup.cron:0 2 * * * ?}")
    public void cleanupOrphanFiles() {
        // 查询超过阈值的 PENDING 任务
        // 删除存储文件
        // 删除任务记录
        // 发送 Micrometer 指标
    }
}
```

### 2. 乐观锁（P1.7）

```java
@Entity
public class TaskAggregate {
    @Version
    private Long version;  // JPA 乐观锁字段
}
```

### 3. 结构化日志（P1.9）

```java
log.info("Task status changed",
    kv("taskId", taskId),
    kv("oldStatus", oldStatus),
    kv("newStatus", newStatus),
    kv("duration", duration)
);
```

## 缓存架构设计（P1.10）

### 设计目标

- **一致性优先**：确保缓存与数据库数据强一致
- **架构解耦**：缓存逻辑对领域层透明，具体实现可插拔
- **防穿透保护**：避免缓存击穿、穿透、雪崩
- **性能提升**：减少数据库查询，提高高频读取场景性能

### 架构分层与职责

```
┌─────────────────────────────────────────────────────┐
│ 应用层 / 领域服务层                                  │
│  - TaskService                                      │
│  - CallbackChainRunner                              │
│    └─ 调用 TaskRepository (领域接口)                │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 领域层                                               │
│  - TaskRepository (interface)                       │
│    + save(TaskAggregate): TaskAggregate            │
│    + findByTaskId(String): Optional<TaskAggregate> │
│    + deleteByTaskId(String): void                  │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 基础设施层 - 仓储实现                                │
│  - TaskRepositoryImpl                               │
│    ├─ 依赖 → TaskJpaRepository (数据库访问)         │
│    ├─ 依赖 → EntityManager (JPA 操作)              │
│    └─ 依赖 → TaskCacheService (缓存抽象接口)       │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 基础设施层 - 缓存抽象                                │
│  - TaskCacheService (interface)                     │
│    + getTask(String): Optional<TaskAggregate>      │
│    + cacheTask(TaskAggregate): void                │
│    + evictTask(String): void                       │
│    + cacheNull(String): void                       │
│    + isNullCached(String): boolean                 │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 基础设施层 - 缓存实现（可插拔）                       │
│  - CaffeineTaskCacheService (本地缓存)              │
│  - RedisTaskCacheService (分布式缓存，未来扩展)      │
│  - MultiLevelCacheService (多级缓存，未来扩展)       │
└─────────────────────────────────────────────────────┘
```

### Cache-Aside 模式（旁路缓存）

**读操作流程**：

```
1. 应用调用 taskRepository.findByTaskId(taskId)
2. TaskRepositoryImpl.findByTaskId():
   ├─ cached = taskCacheService.getTask(taskId)
   ├─ if (cached.isPresent()) return cached.get()  ← 缓存命中
   └─ else:
      ├─ entity = taskJpaRepository.findByTaskId(taskId)
      ├─ if (entity == null):
      │  ├─ taskCacheService.cacheNull(taskId)       ← 防穿透
      │  └─ return Optional.empty()
      └─ else:
         ├─ aggregate = convertToAggregate(entity)
         ├─ taskCacheService.cacheTask(aggregate)    ← 更新缓存
         └─ return Optional.of(aggregate)
```

**写操作流程**：

```
1. 应用调用 taskRepository.save(taskAggregate)
2. TaskRepositoryImpl.save():
   ├─ entity = convertToEntity(taskAggregate)
   ├─ merged = entityManager.merge(entity)
   ├─ entityManager.flush()                        ← 立即持久化
   ├─ taskCacheService.evictTask(taskId)           ← 缓存失效（不是更新！）
   └─ return convertToAggregate(merged)
```

**删除操作流程**：

```
1. 应用调用 taskRepository.deleteByTaskId(taskId)
2. TaskRepositoryImpl.deleteByTaskId():
   ├─ taskJpaRepository.deleteByTaskId(taskId)
   └─ taskCacheService.evictTask(taskId)           ← 缓存失效
```

### 关键设计决策

| 决策点               | 选择                        | 理由                                                      |
| -------------------- | --------------------------- | --------------------------------------------------------- |
| 缓存层次             | Repository 实现层           | 对领域层透明，上层代码无需感知缓存                        |
| 缓存模式             | Cache-Aside                 | 应用控制缓存逻辑，一致性更可控                            |
| 写操作策略           | Write-Invalidate            | 删除缓存而非更新，避免并发更新导致的数据不一致            |
| 缓存抽象             | TaskCacheService 接口       | 缓存实现可插拔（Caffeine/Redis/Multi-level）              |
| NULL 值处理          | 缓存 NULL_MARKER            | 防止缓存穿透（查询不存在的 key 导致每次都查数据库）      |
| 缓存 Key 设计        | taskId (String)             | 与 TaskAggregate 聚合根 ID 保持一致                       |
| 缓存粒度             | 完整 TaskAggregate          | 避免部分字段缓存导致的复杂度和一致性问题                  |

### CaffeineTaskCacheService 实现要点

```java
@Component
public class CaffeineTaskCacheService implements TaskCacheService {
    
    private final Cache<String, TaskAggregate> cache;
    private static final TaskAggregate NULL_MARKER = new TaskAggregate(); // 空值标记
    
    public CaffeineTaskCacheService() {
        this.cache = Caffeine.newBuilder()
            .maximumSize(10_000)           // 最多缓存 10000 个任务
            .expireAfterWrite(30, TimeUnit.SECONDS) // 写入 30 秒后过期
            .recordStats()                 // 启用统计
            .build();
    }
    
    @Override
    public Optional<TaskAggregate> getTask(String taskId) {
        TaskAggregate cached = cache.getIfPresent(taskId);
        if (cached == NULL_MARKER) return Optional.empty(); // NULL 值缓存
        return Optional.ofNullable(cached);
    }
    
    @Override
    public void evictTask(String taskId) {
        cache.invalidate(taskId);  // 删除缓存，不是更新
    }
    
    @Override
    public void cacheNull(String taskId) {
        cache.put(taskId, NULL_MARKER); // 防穿透
    }
}
```

### 一致性保证

**问题：为什么写操作删除缓存而不是更新缓存？**

```
场景：并发写操作
Thread-1: save(task1, status=PROCESSING) → DB 写入 → 更新缓存
Thread-2: save(task1, status=COMPLETED)  → DB 写入 → 更新缓存

问题：如果 Thread-1 的缓存更新晚于 Thread-2，缓存中是旧值 PROCESSING，DB 是 COMPLETED
```

**解决方案：Write-Invalidate**

```
Thread-1: save(task1, status=PROCESSING) → DB 写入 → 删除缓存
Thread-2: save(task1, status=COMPLETED)  → DB 写入 → 删除缓存

结果：缓存中无数据，下次读取强制从 DB 查询，保证一致性
```

### 缓存指标监控（未来优化）

```java
// 通过 Micrometer 暴露 Caffeine 统计指标
@Scheduled(fixedRate = 60000)
public void reportCacheStats() {
    CacheStats stats = cache.stats();
    registry.gauge("cache.hits", stats.hitCount());
    registry.gauge("cache.misses", stats.missCount());
    registry.gauge("cache.evictions", stats.evictionCount());
    registry.gauge("cache.size", cache.estimatedSize());
}
```

### 未来扩展方向

- **Redis 分布式缓存**：适用于多实例部署场景
- **多级缓存**：L1 本地缓存（Caffeine） + L2 分布式缓存（Redis）
- **缓存预热**：应用启动时加载热点任务到缓存
- **智能过期策略**：根据任务状态调整 TTL（COMPLETED 任务缓存更久）

## 待补充

- 监控指标定义与报警策略
- 插件执行模型（同步/异步、重试）
- 领域层实体与应用层 DTO 的映射策略
