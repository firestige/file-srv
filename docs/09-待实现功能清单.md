# 待实现功能清单

> **生成时间**：2026-02-01
> **说明**：基于 [SESSION-TASKCONTEXT-IMPL.md](../SESSION-TASKCONTEXT-IMPL.md) 汇总未完成或跳过的任务。
> **执行建议**：每个任务拆分为子任务逐步完成，避免一次性推理过长。

---

## 总览

- **P1**：配置文档、Redis 缓存未完成
- **P2**：真实分块上传实现未完成
- **P3**：注解驱动（阶段12）、诊断增强（阶段13可选）、分布式追踪（阶段14可选）未完成

---

## P1 阶段（生产就绪优化）

### 1) 配置与文档

- [ ] **P1.5.3** 配置文档完善（可选）
  - 文件：docs/configuration-guide.md
  - **相关决策**：无专门决策点，属于运维文档完善
  - **实现要点**：
    - 汇总所有配置项并分类（Kafka、线程池、超时、重试、孤儿清理）
    - 提供不同业务场景的配置模板（轻量级 vs 重量级操作）
    - 说明各配置项的影响范围和建议值
  - 子任务：
    - [ ] 汇总 application.yml / application-prod.yml 配置项
    - [ ] 说明孤儿清理配置与线程池配置
    - [ ] 补充示例与说明

### 2) 并发控制与缓存

- [ ] **P1.7.3** Redis 缓存层实现（应做）
  - 文件：TaskCacheService.java
  - **相关决策**：[决策点5 - 分布式场景下 TaskContext 持久化策略](../TASKCONTEXT-DECISIONS.md#决策点5分布式场景下-taskcontext-持久化策略)
  - **核心设计**：
    - **DB 为主（权威数据源）+ Redis 为辅（缓存层）**
    - 写入路径：`TaskService → DB (事务) → Redis (async)`
    - 读取路径：`Redis (cache miss) → DB → Redis (fill cache)`
  - **关键原则**：
    - TaskContext 与 TaskAggregate 是聚合根整体，需事务保证一致性
    - Redis 只作性能优化，不能作为唯一数据源
    - 缓存失效时自动回源到 DB
  - 子任务：
    - [ ] 设计缓存 Key 规则（`task:{taskId}`）
    文件：DefaultPluginStorageService.java
  - **相关决策**：[决策点1 - Plugin 写回机制（大文件处理）](../TASKCONTEXT-DECISIONS.md#决策点1taskcontext-元数据注入机制)
  - **当前状态**：已实现阈值判断（5MB），但分片上传逻辑标记为 TODO
  - **设计要点**：
    - 自动选择：size > 5MB 使用分片上传，否则单次上传
    - 调用 StorageAdapter 分片接口：`initiateMultipartUpload()` → `uploadPart()` → `completeMultipartUpload()`
    - 插件无需关心分片细节，透明使用 `uploadLargeFile()` 方法
  - 子任务：
    - [ ] 调研 StorageAdapter 分片接口与限制（分片大小、最大分片数）
    - [ ] 实现分片上传（初始化、循环分片、完成合并（save 后异步更新缓存）

## P2 阶段（开发体验优化）

### 1) 真实分块上传实现（可选）

- [ ] **P2.10.可选** PluginStorageService 分块上传真实实现
  - 子任务：
    - [ ] 调研 StorageAdapter 分片接口与限制
> **相关决策**：[决策点4 - TaskContext 数据管理方案（注解驱动 + 编译时优化）](../TASKCONTEXT-DECISIONS.md#决策点4taskcontext-数据管理方案注解驱动--编译时优化)

**核心设计理念**：
- 用注解描述数据来源（自文档化）
- 用编译时注解处理器生成注入代码（避免反射，零性能开销）
- 类似 Lombok/MapStruct 的代码生成策略

**方案优势**：
- ✅ **自文档化**：`@ContextKey` 注解 + description，一眼看出所有 key 及其用途
- ✅ **编译时检查**：拼写错误在编译期报错，不会到运行时才发现
- ✅ **零反射开销**：生成静态方法，性能等同手写代码
- ✅ **职责清晰**：按阶段生成 Populator，注入逻辑集中管理

---

- [ ] **P3.12.1** 创建 `@ContextKey` 注解
  - 文件：`@ContextKey.java`, `Stage.java` (enum)
  - **注解定义**：
    ```java
    @Retention(RetentionPolicy.SOURCE)  // 编译时处理，运行时不保留
    @Target(ElementType.FIELD)
    public @interface ContextKey {
        Stage stage();           // 注入阶段
        boolean required() default true;  // 是否必需
        String description() default "";  // 字段说明
    }
    ```
> **相关决策**：[决策点7 - TaskContext 变更可观测性](../TASKCONTEXT-DECISIONS.md#决策点7taskcontext-变更可观测性)

**已完成**（P3.13.1-2）：
- ✅ `getAvailableKeys()`：返回所有可用键名
- ✅ `getDiagnosticInfo()`：返回诊断信息（totalKeys, taskId, taskStatus, fileName 等）

**设计原则**：
- 可选功能，性能优先（历史记录有开销）
- 只读访问，不影响 Context 正常使用
- 便于调试、单元测试、生产环境问题排查

---

- [ ] **P3.13.3** 添加 `getHistory()`（可选，性能开销较大）
  - 文件：TaskContext.java
  - **数据结构**：
    ```java
    public record ContextChange(
        Instant timestamp,
        ChangeType type,  // PUT / REMOVE / CLEAR
        String key,
        Object oldValue,
        Object newValue
    ) {}
    ```
  - **实现方式**：
    - 在 `put()`/`remove()` 方法中记录变更
    - 使用 `List<ContextChange>` 存储（线程安全：CopyOnWriteArrayList）
    - 提供 `getHistory()` 返回不可变列表
  - **性能考虑**：
    - 每次修改都创建对象，GC 压力较大
    - 建议通过配置开关控制（`context.history.enabled=false`）
  - 子任务：
    - [ ] 设计 change history 数据结构
    - [ ] 评估性能开销（压测对比）
    - [ ] 提供只读访问（Collections.unmodifiableList）

---

- [ ] **P3.13.4** 添加 `validate()` 方法
  - 文件：TaskContext.java, ContextSchema.java, ValidationResult.java
  - **用途**：
    - 单元测试：验证 Context 注入是否完整
    - 插件开发：快速检查必需字段是否存在
    - 生产环境：定期验证 Context 健康度
  - **实现逻辑**：
    ```java
    public ValidationResult validate(ContextSchema schema) {
        List<String> missingKeys = new ArrayList<>();
        List<String> typeMismatches = new ArrayList<>();
        
        for (String requiredKey : schema.getRequiredKeys()) {
            if (!data.containsKey(requiredKey)) {
                missingKeys.add(requiredKey);
            } else {
                Class<?> expectedType = schema.getExpectedType(requiredKey);
                Object actualValue = data.get(requiredKey);
                if (!expectedType.isInstance(actualValue)) {
                    typeMismatches.add(requiredKey + " (expected: " + 
                        expectedType.getSimpleName() + ", actual: " + 
                        actualValue.getClass().getSimpleName() + ")");
                }
            }
        }
        
        return new ValidationResult(missingKeys, typeMismatches);
    }
    ```
  - 子任务：
    - [ ] 定义 ContextSchema（描述必需字段和类型约束）
    - [ ] 定义 ValidationResult（missingKeys + typeMismatches）

- [ ] **P3.12.2** 实现注解处理器
  - 文件：`ContextKeyProcessor.java`
  - **继承**：`extends AbstractProcessor`
  - **处理逻辑**：
    1. 扫描所有带 `@ContextKey` 注解的字段
    2. 按 `stage` 分组（TASK_CREATION / UPLOAD_COMPLETION / PLUGIN_EXECUTION）
> **相关决策**：[决策点7 - TaskContext 变更可观测性（扩展）](../TASKCONTEXT-DECISIONS.md#决策点7taskcontext-变更可观测性)

**目标**：
- 将 TaskContext 信息注入到分布式追踪 Span
- 跨服务传播 taskId 和 traceId
- 在 Jaeger/Zipkin 中可视化 callback 链执行流程

**收益**：
- ✅ 可视化 callback 链执行流程（哪个插件执行了多久）
- ✅ 快速定位性能瓶颈
- ✅ 跨服务调用链路追踪（任务从创建到完成的完整路径）
- ✅ 与 Prometheus 指标结合提供完整可观测性

---

- [ ] **P3.14.1** 集成 OpenTelemetry
  - 依赖：
    ```xml
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-jaeger</artifactId>
    </dependency>
    ```
  - **配置**：
    ```yaml
    otel:
      service-name: file-srv
      exporter:
        jaeger:
          endpoint: http://localhost:14250
    ```
  - 子任务：
    - [ ] 引入依赖与配置
    - [ ] 创建 TraceConfiguration（配置 Tracer、Exporter）

---

- [ ] **P3.14.2** TaskContext Span 传播
  - 文件：TaskContextLoggingAspect.java（扩展现有 AOP 切面）
  - **实现示例**：
    ```java
    @Aspect
    @Component
    public class TaskContextLoggingAspect {
        private final Tracer tracer;
        
        @Around("execution(* ...TaskAggregate.populateContextForPlugins(..))")
        public Object traceContextInjection(ProceedingJoinPoint pjp) throws Throwable {
            Span span = tracer.spanBuilder("TaskContext.populate")
                .setAttribute("task.id", getCurrentTaskId())
                .setAttribute("task.status", getCurrentStatus())
                .setAttribute("file.name", getCurrentFileName())
                .startSpan();
            
            try (Scope scope = span.makeCurrent()) {
                return pjp.proceed();
            } finally {
                span.end();
            }
        }
    }
    ```
  - 子任务：
    - [ ] TaskContextLoggingAspect 添加 span（扩展现有 AOP）
    - [ ] 关键字段写入 span attributes（taskId, status, fileName）

---

- [ ] **P3.14.3** 跨服务追踪
  - 文件：DefaultCallbackChainRunner.java
  - **实现示例**：
    ```java
    public class DefaultCallbackChainRunner {
        private final Tracer tracer;
        
        public void run(CallbackChain chain) {
            Span chainSpan = tracer.spanBuilder("CallbackChain.run")
                .setAttribute("chain.name", chain.getName())
                .setAttribute("task.id", chain.getTaskId())
                .startSpan();
            
            try (Scope scope = chainSpan.makeCurrent()) {
                for (CallbackPlugin plugin : chain.getPlugins()) {
                    Span pluginSpan = tracer.spanBuilder("Plugin.execute")
                        .setAttribute("plugin.name", plugin.getName())
                        .startSpan();
                    
                    try (Scope pluginScope = pluginSpan.makeCurrent()) {
                        plugin.apply(context);
                    } catch (Exception e) {
                        pluginSpan.recordException(e);
                        throw e;
                    } finally {
                        pluginSpan.end();
                    }
                }
            } finally {
                chainSpan.end();
            }
        }
    }
    ```
  - 子任务：
    - [ ] CallbackChainRunner 创建链级 span（包含 taskId, chainName）
    - [ ] 插件级 span 链路（每个插件创建子 span）
    - [ ] 异常追踪（`span.recordException(e)`）filesrv.apt.ContextKeyProcessor`
  - **验证方式**：
    - 编译时查看 `target/generated-sources/annotations/` 目录
    - 确认生成的 Populator 类存在且可导入
  - 子任务：
    - [ ] 创建 META-INF/services 配置
    - [ ] 验证编译时生效

---

- [ ] **P3.12.4** 使用 JavaPoet 生成代码
  - 依赖：`com.squareup:javapoet:1.13.0`
  - **生成内容**：
    ```java
    // 自动生成 TaskCreationContextPopulator.java
    @Generated("tech.icc.filesrv.apt.ContextKeyProcessor")
    public class TaskCreationContextPopulator {
        public static void populate(TaskContext context, TaskAggregate task) {
            context.put(TaskContextKeys.TASK_ID, task.taskId().value());
            context.put(TaskContextKeys.FILE_NAME, task.filename());
            // ... 其他字段
        }
    }
    ```
  - 子任务：
    - [ ] 生成常量类（按阶段分类）
    - [ ] 生成类型安全访问器（`getTaskId(TaskContext)` 等）
    - [ ] 校验键名格式（正则表达式，如 `^[a-z][a-z0-9.]*[a-z0-9]$`）
    - [ ] 创建 META-INF/services 配置
    - [ ] 验证编译时生效
- [ ] **P3.12.4** 使用 JavaPoet 生成代码
  - 子任务：
    - [ ] 生成常量类
    - [ ] 生成类型安全访问器
    - [ ] 校验键名格式

### 阶段 13：诊断与调试（可选增强）

- [ ] **P3.13.3** 添加 `getHistory()`
  - 子任务：
    - [ ] 设计 change history 数据结构
    - [ ] 评估性能开销
    - [ ] 提供只读访问
- [ ] **P3.13.4** 添加 `validate()` 方法
  - 子任务：
    - [ ] 定义 ContextSchema
    - [ ] 定义 ValidationResult
    - [ ] 实现缺失项与类型校验

### 阶段 14：分布式追踪（可选）

- [ ] **P3.14.1** 集成 OpenTelemetry
  - 子任务：
    - [ ] 引入依赖与配置
    - [ ] 创建 TraceConfiguration
- [ ] **P3.14.2** TaskContext Span 传播
  - 子任务：
    - [ ] TaskContextLoggingAspect 添加 span
    - [ ] 关键字段写入 span attributes
- [ ] **P3.14.3** 跨服务追踪
  - 子任务：
    - [ ] CallbackChainRunner 创建链级 span
    - [ ] 插件级 span 链路

## 建议执行顺序（最短路径）

1. P1 Redis 缓存（如需要）
2. P3 阶段 12（注解驱动）
3. P3 阶段 13（可选增强）
4. P3 阶段 14（可选追踪）

---

## 备注

- 以上任务均来源于实施会话文档中标记为未完成或跳过的项。
- 如需将任务拆分成更小执行单元，可以按模块（common/core/plugins/test）进一步细分。