# 领域模型设计

## 一、设计目标

ICC File Service 定位为**存储运营平台**，核心能力：

| 阶段 | 能力 | 状态 |
|------|------|------|
| **Phase 1** | 单存储 + 去重秒传 | 当前实现 |
| Phase 2 | 多存储池化 + 路由 | 规划中 |
| Phase 3 | 多副本 + 冷热转移 | 规划中 |
| Phase 4 | 写时复制 | 规划中 |

## 二、核心概念

### 2.1 概念模型

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           领域概念模型                                    │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────┐         ┌──────────────┐                             │
│   │FileReference │ N ────→ │   FileInfo   │ (基于 contentHash 去重)      │
│   │  (用户视角)   │    1    │  (物理文件)   │                             │
│   │              │         │              │                             │
│   │  fKey        │         │  contentHash │                             │
│   │  filename    │         │  size        │                             │
│   │  owner       │         │  contentType │                             │
│   │  access      │         │  refCount    │  ←── 引用计数，用于 GC       │
│   └──────────────┘         └──────┬───────┘                             │
│                                   │ 1                                    │
│                                   │                                      │
│                                   ▼ N                                    │
│                           ┌──────────────┐       ┌──────────────┐       │
│                           │ StorageCopy  │ N ──→ │ StorageNode  │       │
│                           │   (副本)      │   1   │   (节点)      │       │
│                           │              │       │              │       │
│                           │  path        │       │  nodeId      │       │
│                           │  status      │       │  tier (热/冷) │       │
│                           │  tier (热/冷) │       │  adapter     │       │
│                           └──────────────┘       └──────────────┘       │
│                                                         │               │
│                                                         ▼               │
│                                                  ┌──────────────┐       │
│                                                  │ StoragePool  │       │
│                                                  │   (存储池)    │       │
│                                                  └──────────────┘       │
└──────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心概念说明

| 概念 | 职责 | 说明 |
|------|------|------|
| **FileReference** | 用户文件引用 | 用户看到的 fKey，支持多用户引用同一内容 |
| **FileInfo** | 物理文件实体 | 以 contentHash 为唯一标识，实现全局去重 |
| **StorageCopy** | 存储副本 | 一个 FileInfo 可有多个副本，分布在不同节点 |
| **StorageNode** | 存储节点 | 对应一个 StorageAdapter 实例（OBS/S3/本地） |
| **StoragePool** | 存储池 | 池化多个节点，统一调度（Phase 2） |
| **StoragePolicy** | 存储策略 | 定义副本数、冷热规则、路由策略 |

### 2.3 关键设计决策

| 决策点 | 选择 | 理由 |
|--------|------|------|
| contentHash 算法 | xxHash-64 | 高性能，适合大文件 |
| Hash 计算时机 | 服务端计算 | Phase 1 简化，后续支持客户端预算 |
| fKey 生成 | UUID v7 | 有序，利于索引；用户隔离 |
| 引用计数策略 | 引用计数 + 异步 GC | 实时 + 防止计数漂移 |
| Phase 1 节点 | 单节点 "primary" | 预留多节点抽象 |

## 三、files 聚合

### 3.1 FileReference（聚合根）

用户文件引用，每个用户上传的文件对应独立的 FileReference，即使内容相同。

```java
package tech.icc.filesrv.core.domain.files;

public record FileReference(
    String fKey,              // 用户文件唯一标识（UUID v7）
    String contentHash,       // 关联的 FileInfo（xxHash-64）
    String filename,          // 用户可见文件名
    String contentType,       // MIME 类型
    Long size,                // 文件大小
    OwnerInfo owner,          // 所有者
    AccessControl access,     // 访问控制
    AuditInfo audit           // 审计信息
) {
    // 工厂方法：创建新引用
    public static FileReference create(String filename, String contentType, 
                                       Long size, OwnerInfo owner);
    
    // 绑定内容（上传完成后）
    public FileReference bindContent(String contentHash);
}
```

### 3.2 FileInfo（实体）

物理文件实体，以 contentHash 为主键，实现全局去重。

```java
package tech.icc.filesrv.core.domain.files;

public record FileInfo(
    String contentHash,           // 主键（xxHash-64）
    Long size,                    // 文件大小
    String contentType,           // MIME 类型
    Integer refCount,             // 引用计数
    FileStatus status,            // PENDING / ACTIVE / DELETED
    List<StorageCopy> copies,     // 存储副本列表
    Instant createdAt
) {
    // 工厂方法：创建待上传文件
    public static FileInfo createPending(String contentHash, Long size, String contentType);
    
    // 激活（上传成功）
    public FileInfo activate(StorageCopy copy);
    
    // 引用计数
    public FileInfo incrementRef();
    public FileInfo decrementRef();
    
    // GC 判断
    public boolean canGC();
    
    // 获取主副本
    public Optional<StorageCopy> getPrimaryCopy();
}
```

### 3.3 FileStatus（枚举）

```java
package tech.icc.filesrv.core.domain.files;

public enum FileStatus {
    PENDING,    // 元数据已创建，文件上传中
    ACTIVE,     // 文件可用
    DELETED;    // 标记删除，等待 GC
    
    public boolean isAccessible() { return this == ACTIVE; }
}
```

### 3.4 仓储接口

```java
// FileReferenceRepository
public interface FileReferenceRepository {
    FileReference save(FileReference reference);
    Optional<FileReference> findByFKey(String fKey);
    List<FileReference> findByOwner(String ownerId);
    void deleteByFKey(String fKey);
    Page<FileReference> findAll(FileReferenceSpec spec, Pageable pageable);
}

// FileInfoRepository
public interface FileInfoRepository {
    FileInfo save(FileInfo fileInfo);
    Optional<FileInfo> findByContentHash(String contentHash);
    int incrementRefCount(String contentHash);  // 原子操作
    int decrementRefCount(String contentHash);  // 原子操作
    List<FileInfo> findGarbageFiles(int limit);
}
```

## 四、storage 聚合

### 4.1 StorageNode（实体）

存储节点，对应一个存储后端实例。

```java
package tech.icc.filesrv.core.domain.storage;

public record StorageNode(
    String nodeId,            // 节点标识（Phase 1: "primary"）
    String name,              // 人类可读名称
    String adapterType,       // 适配器类型："HCS_OBS", "AWS_S3", "LOCAL"
    StorageTier tier,         // 存储层级
    NodeStatus status,        // 节点状态
    String endpoint,          // 连接端点
    String bucket             // 存储桶/根目录
) {
    public boolean isAvailable() { return status == NodeStatus.ACTIVE; }
    public boolean isWritable() { return status == NodeStatus.ACTIVE; }
}
```

### 4.2 StorageCopy（值对象）

存储副本，表示文件在某节点上的一份拷贝。

```java
package tech.icc.filesrv.core.domain.storage;

public record StorageCopy(
    String copyId,            // 副本标识
    String nodeId,            // 所属节点
    String path,              // 存储路径
    StorageTier tier,         // 存储层级
    CopyStatus status,        // 副本状态
    Instant createdAt
) {
    public static StorageCopy create(String nodeId, String path, StorageTier tier);
    public boolean isAvailable() { return status == CopyStatus.ACTIVE; }
}
```

### 4.3 StoragePolicy（值对象）

存储策略。

```java
package tech.icc.filesrv.core.domain.storage;

public record StoragePolicy(
    Integer replicaCount,         // 副本数（Phase 1: 1）
    StorageTier preferredTier,    // 首选存储层级
    Integer retentionDays,        // 保留天数（0 = 永久）
    Boolean enableDeduplication   // 是否启用去重
) {
    public static StoragePolicy defaultPolicy() {
        return new StoragePolicy(1, StorageTier.HOT, 0, true);
    }
}
```

### 4.4 枚举定义

```java
// StorageTier - 存储层级
public enum StorageTier {
    HOT,        // 热存储 - 高频访问，低延迟
    WARM,       // 温存储 - 中频访问
    COLD,       // 冷存储 - 低频访问，低成本
    ARCHIVE;    // 归档存储 - 极低频，最低成本
    
    public boolean isImmediateAccess() {
        return this == HOT || this == WARM;
    }
}

// NodeStatus - 节点状态
public enum NodeStatus {
    ACTIVE,     // 正常服务
    READONLY,   // 只读（迁移中/维护）
    OFFLINE;    // 离线
}

// CopyStatus - 副本状态
public enum CopyStatus {
    PENDING,    // 创建中
    ACTIVE,     // 可用
    MIGRATING,  // 迁移中
    DELETED;    // 已删除
}
```

### 4.5 仓储接口

```java
public interface StorageNodeRepository {
    Optional<StorageNode> findByNodeId(String nodeId);
    List<StorageNode> findByStatus(NodeStatus status);
    List<StorageNode> findByTier(StorageTier tier);
}
```

## 五、领域服务

### 5.1 DeduplicationService

去重服务。

```java
package tech.icc.filesrv.core.domain.services;

public interface DeduplicationService {
    
    /** 检查是否存在相同内容的文件 */
    Optional<FileInfo> findByContentHash(String contentHash);
    
    /** 计算内容哈希（xxHash-64） */
    String computeHash(InputStream content) throws IOException;
    
    /** 增加引用计数（秒传场景） */
    FileInfo incrementReference(String contentHash);
    
    /** 减少引用计数，返回是否可 GC */
    boolean decrementReference(String contentHash);
}
```

### 5.2 StorageRoutingService

存储路由服务。

```java
package tech.icc.filesrv.core.domain.services;

public interface StorageRoutingService {
    
    /** 根据策略选择目标存储节点（Phase 1: 返回 "primary"） */
    StorageNode selectNode(StoragePolicy policy);
    
    /** 获取节点对应的适配器 */
    StorageAdapter getAdapter(String nodeId);
    
    /** 生成存储路径，格式: {hash前2位}/{hash前4位}/{hash} */
    String buildStoragePath(String contentHash, String contentType);
}
```

## 六、基础设施层接口

### 6.1 StorageAdapter

```java
package tech.icc.filesrv.core.infra.storage;

public interface StorageAdapter {
    
    /** 获取适配器类型标识 */
    String getAdapterType();
    
    /** 上传文件 */
    StorageResult upload(String path, InputStream content, String contentType);
    
    /** 下载文件 */
    Resource download(String path);
    
    /** 删除文件 */
    void delete(String path);
    
    /** 检查文件是否存在 */
    boolean exists(String path);
    
    /** 生成预签名 URL */
    String generatePresignedUrl(String path, Duration expiry);
}
```

### 6.2 StorageResult

```java
package tech.icc.filesrv.core.infra.storage;

public record StorageResult(
    String path,          // 实际存储路径
    String checksum,      // 存储层返回的校验和
    Long size,            // 实际存储大小
    Instant uploadedAt
) {}
```

### 6.3 StorageAdapterRegistry

```java
package tech.icc.filesrv.core.infra.storage;

public interface StorageAdapterRegistry {
    
    /** 根据节点 ID 获取适配器 */
    StorageAdapter getAdapter(String nodeId);
    
    /** 注册适配器 */
    void register(String nodeId, StorageAdapter adapter);
    
    /** 获取所有可用节点 */
    List<String> getAvailableNodeIds();
}
```

## 七、upload 流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     FileService.upload() 流程                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 业务校验（大小、类型、权限）                                          │
│                    │                                                    │
│                    ▼                                                    │
│  2. 计算 contentHash（xxHash-64）                                       │
│                    │                                                    │
│                    ▼                                                    │
│  3. 查询 FileInfo by contentHash  ─────────────────┐                   │
│                    │                               │                    │
│              ┌─────┴─────┐                         │                    │
│              ▼           ▼                         │                    │
│         [不存在]      [已存在]                      │                    │
│              │           │                         │                    │
│              │           └──→ 秒传！引用计数 +1 ────┤                   │
│              │                                     │                    │
│              ▼                                     │                    │
│  4. 路由决策：选择目标 StorageNode                  │                    │
│              │                                     │                    │
│              ▼                                     │                    │
│  5. 调用 StorageAdapter.upload()                   │                    │
│              │                                     │                    │
│              ▼                                     │                    │
│  6. 创建 FileInfo + StorageCopy                    │                    │
│              │                                     │                    │
│              └─────────────────────────────────────┘                    │
│                                                    │                    │
│                                                    ▼                    │
│  7. 创建 FileReference（fKey → FileInfo）                               │
│                                                    │                    │
│                                                    ▼                    │
│  8. 返回 FileInfoDto                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 八、Phase 1 Stub 策略

| 组件 | Phase 1 实现 |
|------|-------------|
| `StorageRoutingService.selectNode()` | 固定返回 nodeId="primary" |
| `StorageAdapterRegistry` | 仅注册一个适配器 |
| `StoragePolicy` | 使用 defaultPolicy() |
| `FileInfo.copies` | 单元素列表 |
| `CopyStatus` | 固定 ACTIVE |
| 大文件去重 | 不支持，仅小文件（同步上传） |

## 九、目录结构

```
domain/
├── files/
│   ├── FileReference.java          # 聚合根
│   ├── FileInfo.java               # 实体
│   ├── FileStatus.java             # 枚举
│   ├── FileReferenceRepository.java
│   └── FileInfoRepository.java
│
├── storage/
│   ├── StorageNode.java            # 实体
│   ├── StorageCopy.java            # 值对象
│   ├── StoragePolicy.java          # 值对象
│   ├── StorageTier.java            # 枚举
│   ├── NodeStatus.java             # 枚举
│   ├── CopyStatus.java             # 枚举
│   └── StorageNodeRepository.java
│
├── services/
│   ├── DeduplicationService.java   # 领域服务接口
│   └── StorageRoutingService.java  # 领域服务接口
│
└── tasks/
    └── ... (已有)
```
