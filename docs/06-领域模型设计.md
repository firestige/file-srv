# 领域模型设计

## 一、设计目标

ICC File Service 定位为**存储运营平台**，核心能力：

| 阶段        | 能力              | 状态     |
| ----------- | ----------------- | -------- |
| **Phase 1** | 单存储 + 去重秒传 | 当前实现 |
| Phase 2     | 多存储池化 + 路由 | 规划中   |
| Phase 3     | 多副本 + 冷热转移 | 规划中   |
| Phase 4     | 写时复制          | 规划中   |

## 二、核心概念

### 2.1 概念模型

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           领域概念模型                                    │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────┐         ┌──────────────┐                             │
│   │FileReference │ N ────→ │   FileInfo   │ (基于 contentHash 去重)      │
│   │  (用户视角)   │    1    │  (物理文件)   │                             │
│   │              │         │              │                             │
│   │  fKey        │         │  contentHash │                             │
│   │  filename    │         │  size        │                             │
│   │  owner       │         │  contentType │                             │
│   │  access      │         │  refCount    │  ←── 引用计数，用于 GC       │
│   └──────────────┘         └──────┬───────┘                             │
│                                   │ 1                                    │
│                                   │                                      │
│                                   ▼ N                                    │
│                           ┌──────────────┐       ┌──────────────┐       │
│                           │ StorageCopy  │ N ──→ │ StorageNode  │       │
│                           │   (副本)      │   1   │   (节点)      │       │
│                           │              │       │              │       │
│                           │  path        │       │  nodeId      │       │
│                           │  status      │       │  tier (热/冷) │       │
│                           │  tier (热/冷) │       │  adapter     │       │
│                           └──────────────┘       └──────────────┘       │
│                                                         │               │
│                                                         ▼               │
│                                                  ┌──────────────┐       │
│                                                  │ StoragePool  │       │
│                                                  │   (存储池)    │       │
│                                                  └──────────────┘       │
└──────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心概念说明

| 概念              | 职责         | 说明                                        |
| ----------------- | ------------ | ------------------------------------------- |
| **FileReference** | 用户文件引用 | 用户看到的 fKey，支持多用户引用同一内容     |
| **FileInfo**      | 物理文件实体 | 以 contentHash 为唯一标识，实现全局去重     |
| **StorageCopy**   | 存储副本     | 一个 FileInfo 可有多个副本，分布在不同节点  |
| **StorageNode**   | 存储节点     | 对应一个 StorageAdapter 实例（OBS/S3/本地） |
| **StoragePool**   | 存储池       | 池化多个节点，统一调度（Phase 2）           |
| **StoragePolicy** | 存储策略     | 定义副本数、冷热规则、路由策略              |

### 2.3 关键设计决策

| 决策点           | 选择               | 理由                             |
| ---------------- | ------------------ | -------------------------------- |
| contentHash 算法 | xxHash-64          | 高性能，适合大文件               |
| Hash 计算时机    | 服务端计算         | Phase 1 简化，后续支持客户端预算 |
| fKey 生成        | UUID v7            | 有序，利于索引；用户隔离         |
| 引用计数策略     | 引用计数 + 异步 GC | 实时 + 防止计数漂移              |
| Phase 1 节点     | 单节点 "primary"   | 预留多节点抽象                   |

## 三、files 聚合

### 3.1 FileReference（聚合根）

用户文件引用，每个用户上传的文件对应独立的 FileReference，即使内容相同。

```java
package tech.icc.filesrv.core.domain.files;

public record FileReference(
    String fKey,              // 用户文件唯一标识（UUID v7）
    String contentHash,       // 关联的 FileInfo（xxHash-64）
    String filename,          // 用户可见文件名
    String contentType,       // MIME 类型
    Long size,                // 文件大小
    OwnerInfo owner,          // 所有者
    AccessControl access,     // 访问控制
    AuditInfo audit           // 审计信息
) {
    // 工厂方法：创建新引用
    public static FileReference create(String filename, String contentType,
                                       Long size, OwnerInfo owner);

    // 绑定内容（上传完成后）
    public FileReference bindContent(String contentHash);
}
```

### 3.2 FileInfo（实体）

物理文件实体，以 contentHash 为主键，实现全局去重。

```java
package tech.icc.filesrv.core.domain.files;

public record FileInfo(
    String contentHash,           // 主键（xxHash-64）
    Long size,                    // 文件大小
    String contentType,           // MIME 类型
    Integer refCount,             // 引用计数
    FileStatus status,            // PENDING / ACTIVE / DELETED
    List<StorageCopy> copies,     // 存储副本列表
    Instant createdAt
) {
    // 工厂方法：创建待上传文件
    public static FileInfo createPending(String contentHash, Long size, String contentType);

    // 激活（上传成功）
    public FileInfo activate(StorageCopy copy);

    // 引用计数
    public FileInfo incrementRef();
    public FileInfo decrementRef();

    // GC 判断
    public boolean canGC();

    // 获取主副本
    public Optional<StorageCopy> getPrimaryCopy();
}
```

### 3.3 FileStatus（枚举）

```java
package tech.icc.filesrv.core.domain.files;

public enum FileStatus {
    PENDING,    // 元数据已创建，文件上传中
    ACTIVE,     // 文件可用
    DELETED;    // 标记删除，等待 GC

    public boolean isAccessible() { return this == ACTIVE; }
}
```

### 3.4 仓储接口

```java
// FileReferenceRepository
public interface FileReferenceRepository {
    FileReference save(FileReference reference);
    Optional<FileReference> findByFKey(String fKey);
    List<FileReference> findByOwner(String ownerId);
    void deleteByFKey(String fKey);
    Page<FileReference> findAll(FileReferenceSpec spec, Pageable pageable);
}

// FileInfoRepository
public interface FileInfoRepository {
    FileInfo save(FileInfo fileInfo);
    Optional<FileInfo> findByContentHash(String contentHash);
    int incrementRefCount(String contentHash);  // 原子操作
    int decrementRefCount(String contentHash);  // 原子操作
    List<FileInfo> findGarbageFiles(int limit);
}
```

## 四、storage 聚合

### 4.1 StorageNode（实体）

存储节点，对应一个存储后端实例。

```java
package tech.icc.filesrv.core.domain.storage;

public record StorageNode(
    String nodeId,            // 节点标识（Phase 1: "primary"）
    String name,              // 人类可读名称
    String adapterType,       // 适配器类型："HCS_OBS", "AWS_S3", "LOCAL"
    StorageTier tier,         // 存储层级
    NodeStatus status,        // 节点状态
    String endpoint,          // 连接端点
    String bucket             // 存储桶/根目录
) {
    public boolean isAvailable() { return status == NodeStatus.ACTIVE; }
    public boolean isWritable() { return status == NodeStatus.ACTIVE; }
}
```

### 4.2 StorageCopy（值对象）

存储副本，表示文件在某节点上的一份拷贝。

```java
package tech.icc.filesrv.core.domain.storage;

public record StorageCopy(
    String copyId,            // 副本标识
    String nodeId,            // 所属节点
    String path,              // 存储路径
    StorageTier tier,         // 存储层级
    CopyStatus status,        // 副本状态
    Instant createdAt
) {
    public static StorageCopy create(String nodeId, String path, StorageTier tier);
    public boolean isAvailable() { return status == CopyStatus.ACTIVE; }
}
```

### 4.3 StoragePolicy（值对象）

存储策略。

```java
package tech.icc.filesrv.core.domain.storage;

public record StoragePolicy(
    Integer replicaCount,         // 副本数（Phase 1: 1）
    StorageTier preferredTier,    // 首选存储层级
    Integer retentionDays,        // 保留天数（0 = 永久）
    Boolean enableDeduplication   // 是否启用去重
) {
    public static StoragePolicy defaultPolicy() {
        return new StoragePolicy(1, StorageTier.HOT, 0, true);
    }
}
```

### 4.4 枚举定义

```java
// StorageTier - 存储层级
public enum StorageTier {
    HOT,        // 热存储 - 高频访问，低延迟
    WARM,       // 温存储 - 中频访问
    COLD,       // 冷存储 - 低频访问，低成本
    ARCHIVE;    // 归档存储 - 极低频，最低成本

    public boolean isImmediateAccess() {
        return this == HOT || this == WARM;
    }
}

// NodeStatus - 节点状态
public enum NodeStatus {
    ACTIVE,     // 正常服务
    READONLY,   // 只读（迁移中/维护）
    OFFLINE;    // 离线
}

// CopyStatus - 副本状态
public enum CopyStatus {
    PENDING,    // 创建中
    ACTIVE,     // 可用
    MIGRATING,  // 迁移中
    DELETED;    // 已删除
}
```

### 4.5 仓储接口

```java
public interface StorageNodeRepository {
    Optional<StorageNode> findByNodeId(String nodeId);
    List<StorageNode> findByStatus(NodeStatus status);
    List<StorageNode> findByTier(StorageTier tier);
}
```

## 五、领域服务

### 5.1 DeduplicationService

去重服务。

```java
package tech.icc.filesrv.core.domain.services;

public interface DeduplicationService {

    /** 检查是否存在相同内容的文件 */
    Optional<FileInfo> findByContentHash(String contentHash);

    /** 计算内容哈希（xxHash-64） */
    String computeHash(InputStream content) throws IOException;

    /** 增加引用计数（秒传场景） */
    FileInfo incrementReference(String contentHash);

    /** 减少引用计数，返回是否可 GC */
    boolean decrementReference(String contentHash);
}
```

### 5.2 StorageRoutingService

存储路由服务。

```java
package tech.icc.filesrv.core.domain.services;

public interface StorageRoutingService {

    /** 根据策略选择目标存储节点（Phase 1: 返回 "primary"） */
    StorageNode selectNode(StoragePolicy policy);

    /** 获取节点对应的适配器 */
    StorageAdapter getAdapter(String nodeId);

    /** 生成存储路径，格式: {hash前2位}/{hash前4位}/{hash} */
    String buildStoragePath(String contentHash, String contentType);
}
```

## 六、基础设施层接口

### 6.1 StorageAdapter

```java
package tech.icc.filesrv.core.infra.storage;

public interface StorageAdapter {

    /** 获取适配器类型标识 */
    String getAdapterType();

    /** 上传文件 */
    StorageResult upload(String path, InputStream content, String contentType);

    /** 下载文件 */
    Resource download(String path);

    /** 删除文件 */
    void delete(String path);

    /** 检查文件是否存在 */
    boolean exists(String path);

    /** 生成预签名 URL */
    String generatePresignedUrl(String path, Duration expiry);
}
```

### 6.2 StorageResult

```java
package tech.icc.filesrv.core.infra.storage;

public record StorageResult(
    String path,          // 实际存储路径
    String checksum,      // 存储层返回的校验和
    Long size,            // 实际存储大小
    Instant uploadedAt
) {}
```

### 6.3 StorageAdapterRegistry

```java
package tech.icc.filesrv.core.infra.storage;

public interface StorageAdapterRegistry {

    /** 根据节点 ID 获取适配器 */
    StorageAdapter getAdapter(String nodeId);

    /** 注册适配器 */
    void register(String nodeId, StorageAdapter adapter);

    /** 获取所有可用节点 */
    List<String> getAvailableNodeIds();
}
```

## 七、upload 流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     FileService.upload() 流程                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 业务校验（大小、类型、权限）                                          │
│                    │                                                    │
│                    ▼                                                    │
│  2. 计算 contentHash（xxHash-64）                                       │
│                    │                                                    │
│                    ▼                                                    │
│  3. 查询 FileInfo by contentHash  ─────────────────┐                   │
│                    │                               │                    │
│              ┌─────┴─────┐                         │                    │
│              ▼           ▼                         │                    │
│         [不存在]      [已存在]                      │                    │
│              │           │                         │                    │
│              │           └──→ 秒传！引用计数 +1 ────┤                   │
│              │                                     │                    │
│              ▼                                     │                    │
│  4. 路由决策：选择目标 StorageNode                  │                    │
│              │                                     │                    │
│              ▼                                     │                    │
│  5. 调用 StorageAdapter.upload()                   │                    │
│              │                                     │                    │
│              ▼                                     │                    │
│  6. 创建 FileInfo + StorageCopy                    │                    │
│              │                                     │                    │
│              └─────────────────────────────────────┘                    │
│                                                    │                    │
│                                                    ▼                    │
│  7. 创建 FileReference（fKey → FileInfo）                               │
│                                                    │                    │
│                                                    ▼                    │
│  8. 返回 FileInfoDto                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 八、Phase 1 Stub 策略

| 组件                                 | Phase 1 实现                 |
| ------------------------------------ | ---------------------------- |
| `StorageRoutingService.selectNode()` | 固定返回 nodeId="primary"    |
| `StorageAdapterRegistry`             | 仅注册一个适配器             |
| `StoragePolicy`                      | 使用 defaultPolicy()         |
| `FileInfo.copies`                    | 单元素列表                   |
| `CopyStatus`                         | 固定 ACTIVE                  |
| 大文件去重                           | 不支持，仅小文件（同步上传） |

## 九、目录结构

```
domain/
├── files/
│   ├── FileReference.java          # 聚合根
│   ├── FileInfo.java               # 实体
│   ├── FileStatus.java             # 枚举
│   ├── FileReferenceRepository.java
│   └── FileInfoRepository.java
│
├── storage/
│   ├── StorageNode.java            # 实体
│   ├── StorageCopy.java            # 值对象
│   ├── StoragePolicy.java          # 值对象
│   ├── StorageTier.java            # 枚举
│   ├── NodeStatus.java             # 枚举
│   ├── CopyStatus.java             # 枚举
│   └── StorageNodeRepository.java
│
├── services/
│   ├── DeduplicationService.java   # 领域服务接口
│   └── StorageRoutingService.java  # 领域服务接口
│
└── tasks/                          # 上传任务聚合
    ├── TaskAggregate.java          # 聚合根
    ├── TaskRepository.java         # 仓储接口
    └── PartInfo.java               # 分片信息值对象
```

## 十、tasks 聚合（上传任务）

> 详细设计见 [07-异步任务上传设计.md](./07-异步任务上传设计.md)

### 10.1 TaskAggregate（聚合根）

异步上传任务，独立于 FileReference 的生命周期。

```java
package tech.icc.filesrv.core.domain.tasks;

@Entity
@Table(name = "upload_task")
public class TaskAggregate {

    @Id
    private String taskId;              // UUID，任务唯一标识

    @Embedded
    private FKey fKey;                  // 用户文件标识 (appId + bizKey + path)

    @Enumerated(EnumType.STRING)
    private TaskStatus status;          // PENDING → IN_PROGRESS → PROCESSING → COMPLETED/FAILED

    private String nodeId;              // 当前处理节点 (集群场景)
    private String sessionId;           // 存储层上传会话 ID
    private String storagePath;         // 最终存储路径 (完成后填充)

    private String hash;                // 文件哈希 (用于去重)
    private Long totalSize;             // 文件总大小

    @ElementCollection
    private List<PartInfo> parts;       // 已上传分片列表

    @ElementCollection
    private List<String> callbacks;     // 待执行 Plugin 名称列表

    private int currentCallbackIndex;   // 当前执行到第几个 callback (断点恢复)

    @Embedded
    private TaskContext context;        // Plugin 执行上下文 (参数 + 输出)

    private String failureReason;       // 失败原因

    private Instant createdAt;
    private Instant expiresAt;          // 超时时间
    private Instant completedAt;

    // === 领域行为 ===
    public void startUpload(String sessionId);
    public void recordPart(PartInfo part);
    public void completeUpload(String storagePath);
    public void advanceCallback();
    public void markCompleted();
    public void markFailed(String reason);
    public void abort();
}
```

### 10.2 PartInfo（值对象）

```java
package tech.icc.filesrv.core.domain.tasks;

@Embeddable
public record PartInfo(
    int partNumber,     // 分片序号 (1-based)
    String etag,        // 存储层返回的 ETag
    long size           // 分片大小
) {}
```

### 10.3 TaskRepository

```java
package tech.icc.filesrv.core.domain.tasks;

public interface TaskRepository {

    TaskAggregate save(TaskAggregate task);

    Optional<TaskAggregate> findByTaskId(String taskId);

    List<TaskAggregate> findByFKey(FKey fKey);

    List<TaskAggregate> findByStatus(TaskStatus status, Pageable pageable);

    List<TaskAggregate> findExpiredTasks(Instant before, int limit);

    void deleteByTaskId(String taskId);
}
```

### 10.4 与 files 聚合的关系

```
┌─────────────────────────────────────────────────────────────────────┐
│                        聚合关系                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌───────────────┐                        ┌───────────────┐        │
│  │ TaskAggregate │                        │ FileReference │        │
│  │   (临时)       │                        │   (永久)      │        │
│  │               │                        │               │        │
│  │  taskId       │                        │  fKey         │        │
│  │  fKey ────────┼───── 完成后创建 ──────►│  contentHash  │        │
│  │  status       │                        │  filename     │        │
│  │  sessionId    │                        │               │        │
│  │  parts[]      │                        └───────────────┘        │
│  │  callbacks[]  │                               │                  │
│  │  context      │                               │ N:1              │
│  │               │                               ▼                  │
│  │ 生命周期: 短   │                        ┌───────────────┐        │
│  │ 任务完成后     │                        │   FileInfo    │        │
│  │ 可删除或归档   │                        │   (物理文件)   │        │
│  └───────────────┘                        │               │        │
│                                           │  contentHash  │        │
│                                           │  refCount     │        │
│                                           │  copies[]     │        │
│                                           │               │        │
│                                           │ 生命周期: 长   │        │
│                                           │ 引用计数归零   │        │
│                                           │ 后 GC 删除    │        │
│                                           └───────────────┘        │
└─────────────────────────────────────────────────────────────────────┘
```

**关键约束**：

- TaskAggregate 使用 `fKey` 标识用户意图，但不直接持有 FileReference
- 任务完成时，由 TaskService 创建 FileReference 并关联 FileInfo
- 任务失败/超时后，可安全删除 TaskAggregate，不影响已有文件

## 十一、文件关系追踪（P0.1）

### 11.1 设计背景

插件执行过程中经常产生**派生文件**（例如：缩略图、转码视频、水印图），需要跟踪源文件与派生文件的关系：

- **查询场景**：给定源文件，查询所有派生文件
- **级联删除**：删除源文件时，同时删除所有派生文件
- **引用关系**：支持多级派生（源文件 → 缩略图 → 裁剪图）

### 11.2 FileRelations（值对象）

```java
package tech.icc.filesrv.common.domain;

/**
 * 文件关系值对象
 * 记录源文件、当前主文件、派生文件的关系
 */
public record FileRelations(
    String sourceKey,        // 源文件 fKey（最初上传的文件）
    String currentMainKey,   // 当前主文件 fKey（可能是源文件，也可能是派生文件）
    Set<String> derivedKeys  // 派生文件 fKey 集合（不可变）
) {
    public FileRelations {
        derivedKeys = derivedKeys != null 
            ? Collections.unmodifiableSet(new HashSet<>(derivedKeys)) 
            : Collections.emptySet();
    }
    
    // 工厂方法：创建初始关系
    public static FileRelations ofSource(String sourceKey) {
        return new FileRelations(sourceKey, sourceKey, new HashSet<>());
    }
    
    // 添加派生文件
    public FileRelations addDerived(String... keys) {
        Set<String> newDerived = new HashSet<>(derivedKeys);
        newDerived.addAll(Arrays.asList(keys));
        return new FileRelations(sourceKey, currentMainKey, newDerived);
    }
    
    // 检查是否包含派生文件
    public boolean hasDerived(String key) {
        return derivedKeys.contains(key);
    }
}
```

### 11.3 领域事件（P0.3）

为了避免 TaskAggregate 直接依赖 FileRelationsRepository（违反 DDD 聚合边界），使用 **Spring 应用事件** 解耦：

```java
package tech.icc.filesrv.core.domain.files.events;

/**
 * 派生文件添加事件
 * 当 callback 执行完成并产生派生文件时发布
 */
public class DerivedFilesAddedEvent extends ApplicationEvent {
    private final String taskId;
    private final String sourceFileKey;
    private final List<String> derivedFileKeys;
    
    public DerivedFilesAddedEvent(
        Object source,
        String taskId,
        String sourceFileKey,
        List<String> derivedFileKeys
    ) {
        super(source);
        this.taskId = taskId;
        this.sourceFileKey = sourceFileKey;
        this.derivedFileKeys = List.copyOf(derivedFileKeys);
    }
    
    // Getters...
}
```

### 11.4 事件处理器（P0.3）

```java
package tech.icc.filesrv.core.infra.persistence.files;

@Component
@RequiredArgsConstructor
public class FileRelationsEventHandler {
    
    private final FileRelationsRepository repository;
    
    @EventListener
    @Transactional
    public void handleDerivedFilesAdded(DerivedFilesAddedEvent event) {
        String sourceKey = event.getSourceFileKey();
        List<String> derivedKeys = event.getDerivedFileKeys();
        
        // 查询或创建 FileRelations
        FileRelations relations = repository.findBySourceKey(sourceKey)
            .orElseGet(() -> FileRelations.ofSource(sourceKey));
        
        // 添加派生文件
        FileRelations updated = relations.addDerived(
            derivedKeys.toArray(new String[0])
        );
        
        // 保存到数据库
        repository.save(updated);
        
        log.info("Updated file relations",
            kv("sourceKey", sourceKey),
            kv("derivedKeys", derivedKeys),
            kv("totalDerived", updated.derivedKeys().size())
        );
    }
}
```

### 11.5 Callback 链集成

```java
// DefaultCallbackChainRunner.java
public TaskContext executeCallbacks(TaskAggregate aggregate, Path localFilePath) {
    // ... 执行插件链 ...
    
    // 检查是否有派生文件
    List<String> derivedKeys = context.getStringList(
        TaskContextKeys.DERIVED_FILE_KEYS
    );
    
    if (!derivedKeys.isEmpty()) {
        // 发布领域事件，由 FileRelationsEventHandler 处理
        applicationEventPublisher.publishEvent(
            new DerivedFilesAddedEvent(
                this,
                aggregate.taskId().value(),
                aggregate.fKey().value(),
                derivedKeys
            )
        );
    }
    
    return context;
}
```

### 11.6 数据库映射

```java
@Entity
@Table(name = "file_relations")
public class FileRelationsEntity {
    @Id
    private String sourceKey;  // 主键
    
    private String currentMainKey;
    
    @ElementCollection
    @CollectionTable(
        name = "file_derived_keys",
        joinColumns = @JoinColumn(name = "source_key")
    )
    @Column(name = "derived_key")
    private Set<String> derivedKeys;
    
    // 转换为领域对象
    public FileRelations toDomain() {
        return new FileRelations(sourceKey, currentMainKey, derivedKeys);
    }
}
```

### 11.7 架构决策记录

| 决策点               | 选择                   | 理由                                           |
| -------------------- | ---------------------- | ---------------------------------------------- |
| 值对象 vs 实体       | 值对象                 | 关系数据本身没有生命周期，依附于文件           |
| 跨聚合更新方式       | Spring 应用事件        | 避免 TaskAggregate 依赖 FileRelationsRepository |
| 事件类型             | ApplicationEvent       | 进程内同步事件，性能高，无需 Kafka              |
| 派生文件存储         | Set                    | 去重、无序、快速查找                           |
| sourceKey vs fKey    | sourceKey 作为主键     | 所有派生关系以源文件为根节点                   |
| 级联删除实现方式     | 应用层查询后批量删除   | Phase 1 简化实现，Phase 2 可考虑 DB 触发器    |

### 11.8 使用示例

```java
// 插件中记录派生文件
public PluginResult apply(TaskContext context) {
    // 生成缩略图
    String thumbnailKey = generateThumbnail(context);
    
    // 记录派生文件到 context
    context.addToList(
        TaskContextKeys.DERIVED_FILE_KEYS, 
        thumbnailKey
    );
    
    return PluginResult.success("Thumbnail generated");
}

// 查询派生文件
Optional<FileRelations> relations = repository.findBySourceKey(sourceKey);
relations.ifPresent(r -> {
    Set<String> derivedKeys = r.derivedKeys();
    // 删除所有派生文件
    derivedKeys.forEach(key -> fileService.delete(key));
});
```

